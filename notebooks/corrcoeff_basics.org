#+TITLE: Basic idea and plot to study correlation between CMB temperature and CMB polarization
#+AUTHOR: Xavier Garrido
#+EMAIL: xavier.garrido@lal.in2p3.fr
#+STARTUP: inlineimages

* Emacs config                                                     :noexport:
#+BEGIN_SRC elisp :session venv :results none
  (pyvenv-workon "software-XP2uSSFK")
#+END_SRC

* Plotting correlation between temperature and polarization

Set fiducial values of cosmological parameters to be set to =CAMB=
#+BEGIN_SRC ipython :session venv :results none
  params = {
      "ombh2": 0.022, "omch2": 0.12, "H0": 68, "tau": 0.07,
      "As": 2.2e-9, "ns": 0.96,
      "mnu": 0.06, "nnu": 3.046, "num_massive_neutrinos": 1}
#+END_SRC

Let's put this dictionary of values into =cobaya= internal system of configuration
#+BEGIN_SRC ipython :session venv :results none
  info = {
      "params": params,
      "likelihood": {"one": None},
      "theory": {"camb": None}
  }
#+END_SRC

We will now get the model given the above parameters
#+BEGIN_SRC ipython :session venv :results none
  from cobaya.model import get_model
  camb_model = get_model(info)
#+END_SRC
Then set it to retrieve power spectra
#+BEGIN_SRC ipython :session venv :results none
  lmin, lmax = 2, 3000
  camb_model.likelihood.theory.needs(Cl={"tt": lmax, "te": lmax, "ee": lmax})
#+END_SRC
and compute the CMB power spectra (=ell_factor=True= means normalization by $\ell(\ell+1)/(2\pi)$)
#+BEGIN_SRC ipython :session venv :results none
  camb_model.logposterior({})
  Dls = camb_model.likelihood.theory.get_cl(ell_factor=False)
#+END_SRC

Finally, let's plot things between $(\ell_\text{min}, \ell_\text{max})$
#+BEGIN_SRC ipython :session venv :results raw drawer
  %matplotlib inline
  import numpy as np
  import matplotlib.pyplot as plt

  l = np.arange(lmin, lmax)
  y = (Dls["te"]/np.sqrt(Dls["tt"]*Dls["ee"]))
  plt.plot(l, y[lmin:lmax])
  plt.xlabel(r"$\ell$")
  plt.ylabel(r"$R_{\rm TT, EE}$")
#+END_SRC

#+RESULTS:
:results:
# Out[6]:
: Text(0, 0.5, '$R_{\\rm TT, EE}$')
[[file:./obipy-resources/IInr1L.png]]
:end:
* Plotting dependence to cosmological parameters
#+BEGIN_SRC ipython :session venv :results none
  def plot_correlation(param_name="H0", amplitude=0.1):
      import matplotlib
      cmap = matplotlib.cm.get_cmap("RdBu_r")

      n = 10
      pars = np.linspace(params[param_name]*(1-amplitude),
                         params[param_name]*(1+amplitude), n)
      for i, p in enumerate(pars):
          from copy import deepcopy
          my_params = deepcopy(params)
          my_params[param_name] = p
          info = {
              "params": my_params,
              "likelihood": {"one": None},
              "theory": {"camb": None}
          }
          from cobaya.model import get_model
          camb_model = get_model(info)
          lmin, lmax = 2, 2000
          camb_model.likelihood.theory.needs(Cl={"tt": lmax, "te": lmax, "ee": lmax})
          camb_model.logposterior({})
          Dls = camb_model.likelihood.theory.get_cl(ell_factor=True)
          l = np.arange(lmin, lmax)
          y = (Dls["te"]/np.sqrt(Dls["tt"]*Dls["ee"]))[lmin:lmax]
          plt.plot(l, y, color=cmap(i/n))
      plt.xlabel(r"$\ell$")
      plt.ylabel(r"$R_{\rm TT, EE}$")
      sm = plt.cm.ScalarMappable(cmap=cmap, norm=plt.Normalize(vmin=pars[0], vmax=pars[-1]))
      latex = {"ombh2": "$\Omega_\mathrm{b}h^2$",
               "omch2": "$\Omega_\mathrm{c}h^2$",
               "H0": "$H_0$ [km/s]",
               "tau": r"$\tau$",
               "As": "$A_\mathrm{s}$",
               "ns": "$n_\mathrm{s}$",
               "mnu": r"$m_\nu$"}
      plt.colorbar(sm, label=latex[param_name])
#+END_SRC

** H0
Varying H0 by \pm 10% arrounf its fiducial value
#+BEGIN_SRC ipython :session venv :results raw drawer
  plot_correlation("H0")
#+END_SRC

#+RESULTS:
:results:
# Out[55]:
[[file:./obipy-resources/DWFveJ.png]]
:end:
** \Omega_{b}h^2
#+BEGIN_SRC ipython :session venv :results raw drawer
  plot_correlation("ombh2")
#+END_SRC

#+RESULTS:
:results:
# Out[56]:
[[file:./obipy-resources/lsisNn.png]]
:end:
** \Omega_{c}h^2
#+BEGIN_SRC ipython :session venv :results raw drawer
  plot_correlation("omch2")
#+END_SRC

#+RESULTS:
:results:
# Out[57]:
[[file:./obipy-resources/RzsI0u.png]]
:end:
** \tau
#+BEGIN_SRC ipython :session venv :results raw drawer
  plot_correlation("tau")
#+END_SRC

#+RESULTS:
:results:
# Out[61]:
[[file:./obipy-resources/mI1WAS.png]]
:end:
** As
#+BEGIN_SRC ipython :session venv :results raw drawer
  plot_correlation("As")
#+END_SRC

#+RESULTS:
:results:
# Out[62]:
[[file:./obipy-resources/yaBAB9.png]]
:end:
** ns
#+BEGIN_SRC ipython :session venv :results raw drawer
  plot_correlation("ns")
#+END_SRC

#+RESULTS:
:results:
# Out[63]:
[[file:./obipy-resources/0tclP7.png]]
:end:
** m_\nu
#+BEGIN_SRC ipython :session venv :results raw drawer
  plot_correlation("mnu")
#+END_SRC

#+RESULTS:
:results:
# Out[67]:
[[file:./obipy-resources/Tbe2wd.png]]
:end:
* Plotting variance of correlation coefficient
#+BEGIN_SRC ipython :session venv :results raw drawer
  Rl = (Dls["te"]/np.sqrt(Dls["tt"]*Dls["ee"]))[lmin:lmax]
  covmat = 1/(2*l+1)*(Rl**4-2*Rl**2+1)
  plt.plot(l, Rl)
  plt.fill_between(l, Rl-np.sqrt(covmat), Rl+np.sqrt(covmat))
  Rl_obs = Rl + np.sqrt(covmat)*np.random.randn(np.alen(l))
  plt.plot(l, Rl_obs, ".")
#+END_SRC

#+RESULTS:
:results:
# Out[15]:
: [<matplotlib.lines.Line2D at 0x7f42c6e4df90>]
[[file:./obipy-resources/q62LwX.png]]
:end:

#+BEGIN_SRC ipython :session venv :results raw drawer
plt.plot(l, (Rl-Rl_obs)/np.sqrt(covmat), ".")
#+END_SRC

#+RESULTS:
:results:
# Out[17]:
: [<matplotlib.lines.Line2D at 0x7f42c6d15c10>]
[[file:./obipy-resources/8souQI.png]]
:end:

#+BEGIN_SRC ipython :session venv :results raw drawer
  Cl_te = Dls["te"][lmin:lmax]
  Cl_tt = Dls["tt"][lmin:lmax]
  Cl_ee = Dls["ee"][lmin:lmax]
  plt.semilogy(l, Cl_te)
  covmat = 1/(2*l+1)*(Cl_tt*Cl_ee-Cl_te**2)
  Cl_obs = Cl_te + np.sqrt(covmat)*np.random.randn(np.alen(l))
  plt.plot(l, Cl_obs, ".")
#+END_SRC

#+RESULTS:
:results:
# Out[23]:
: [<matplotlib.lines.Line2D at 0x7f42c6931410>]
[[file:./obipy-resources/W3qvsu.png]]
:end:

#+BEGIN_SRC ipython :session venv :results raw drawer
plt.plot(l, (Cl_te-Cl_obs)/np.sqrt(covmat), ".")
#+END_SRC

#+RESULTS:
:results:
# Out[24]:
: [<matplotlib.lines.Line2D at 0x7f42c67942d0>]
[[file:./obipy-resources/pG5urk.png]]
:end:

* SO noise
#+BEGIN_SRC ipython :session venv :results none
  import numpy as np
  import yaml
  with open("../yaml/corrcoeff.yaml", "r") as stream:
      setup = yaml.load(stream)

  # Get experiment setup
  experiment = setup["experiment"]
  fsky = experiment["fsky"]
  lmin, lmax = 1, 8000
  experiment["lmin"] = lmin
  experiment["lmax"] = lmax
  ells = np.arange(lmin, lmax)


  from corrcoeff import utils
  Cls = utils.get_theory_cls(setup, lmax)
  ls = np.arange(lmin, lmax)
  Cl_TT = Cls["tt"][lmin:lmax]
  Cl_TE = Cls["te"][lmin:lmax]
  Cl_EE = Cls["ee"][lmin:lmax]

  modes = ["baseline", "goal"]
  N_TT, N_EE = {}, {}
  for i, m in enumerate(modes):
    experiment["sensitivity_mode"] = i+1
    N_TT[m], N_EE[m] = utils.get_noise(experiment)
#+END_SRC

#+BEGIN_SRC ipython :session venv :results raw drawer
  import matplotlib.pyplot as plt
  %matplotlib inline
  plt.rcParams["xtick.top"] = plt.rcParams["ytick.right"] = True

  plt.figure(figsize=(8,14))
  grid = plt.GridSpec(2, 1, hspace=0.25, wspace=0)

  norm = ells*(ells+1)/(2*np.pi)

  TT = plt.subplot(grid[0])
  TT.semilogy()
  TT.plot([], [], c="gray", ls="-", label="baseline")
  TT.plot([], [], c="gray", ls="--", label="goal")
  TT.plot(ls, norm*Cl_TT, "k", label="Lensed CMB TT")
  EE = plt.subplot(grid[1])
  EE.semilogy()
  EE.plot([], [], c="gray", ls="-", label="baseline")
  EE.plot([], [], c="gray", ls="--", label="goal")
  EE.plot(ls, norm*Cl_EE, "k", label="Lensed CMB EE")

  freqs = experiment["freq_all"]
  for i, f in enumerate(freqs):
    TT.plot(ells, norm*N_TT["baseline"][i], "-C{}".format(i), label="{} GHz".format(f))
    TT.plot(ells, norm*N_TT["goal"][i], "--C{}".format(i))
    EE.plot(ells, norm*N_EE["baseline"][i], "-C{}".format(i), label="{} GHz".format(f))
    EE.plot(ells, norm*N_EE["goal"][i], "--C{}".format(i))

  TT.set_ylim(1, 10**5)
  TT.set_xlim(lmin, lmax)
  TT.set_title("SO LAT $TT$ Noise Power Spectra ($f_\mathrm{{sky}} = {}$)".format(fsky))
  TT.set_ylabel("$\ell(\ell+1)C_\ell/(2\pi)~[\mu\mathrm{K}^2]$")
  TT.set_xlabel("Multipole $\ell$")
  TT.legend(ncol=3, loc="lower right")
  EE.set_ylim(10**-2, 10**5)
  EE.set_xlim(lmin, lmax)
  EE.set_title(r"SO LAT $EE/BB$ Noise Power Spectra ($f_\mathrm{{sky}} = {}$)".format(fsky))
  EE.set_ylabel("$\ell(\ell+1)C_\ell/(2\pi)~[\mu\mathrm{K}^2]$")
  EE.set_xlabel("Multipole $\ell$")
  EE.legend(ncol=3, loc="lower right")
#+END_SRC

#+RESULTS:
:results:
# Out[25]:
: <matplotlib.legend.Legend at 0x7f6d46409650>
[[file:./obipy-resources/JwyqWq.png]]
:end:

* Fisher matrix for joint analysis
#+BEGIN_SRC ipython :session venv :results raw drawer
  import yaml
  with open("../yaml/corrcoeff.yaml", "r") as stream:
      setup = yaml.load(stream)

  # Update cobaya setup
  cparams = setup.get("cobaya").get("params")
  params = [k for k, v in cparams.items() if isinstance(v, dict)
            and "prior" in v.keys() and "proposal" not in v.keys()]
#+END_SRC

#+RESULTS:
:results:
# Out[23]:
:end:

#+BEGIN_SRC ipython :session venv :results raw drawer
    import numpy as np
    experiment = setup["experiment"]
    lmin, lmax = experiment["lmin"], experiment["lmax"]
    fsky = experiment["fsky"]

    add_noise = True
    nell = lmax - lmin

    from corrcoeff import utils
    if add_noise:
        # Get SO noise
        N_TT, N_EE = utils.get_noise(experiment)
        N_TT, N_EE = 1/np.sum(1/N_TT, axis=0), 1/np.sum(1/N_EE, axis=0)
    else:
        N_TT = 0.0
        N_EE = 0.0
    Cl = utils.get_theory_cls(setup, lmax)
    C = np.array([[Cl["tt"][lmin:lmax] + N_TT, Cl["te"][lmin:lmax]],
                  [Cl["te"][lmin:lmax], Cl["ee"][lmin:lmax] + N_EE]])
    inv_C = np.empty_like(C)
    for l in range(nell):
      inv_C[:,:,l] = np.linalg.inv(C[:,:,l])
#+END_SRC

#+RESULTS:
:results:
# Out[49]:
:end:

#+BEGIN_SRC ipython :session venv :results raw drawer
  from copy import deepcopy
  epsilon = 0.01
  deriv = np.empty((len(params), 2, 2, nell))
  for i, p in enumerate(params):
      setup_mod = deepcopy(setup)
      parname = p if p != "logA" else "As"
      value = setup["simulation"]["cosmo. parameters"][parname]
      setup_mod["simulation"]["cosmo. parameters"][parname] = (1-epsilon)*value
      Cl_minus = utils.get_theory_cls(setup_mod, lmax)
      setup_mod["simulation"]["cosmo. parameters"][parname] = (1+epsilon)*value
      Cl_plus = utils.get_theory_cls(setup_mod, lmax)

      d = {}
      for s in ["tt", "te", "ee", "R"]:
          if s == "R":
              plus = Cl_plus["te"]/np.sqrt(Cl_plus["tt"]*Cl_plus["ee"])
              minus = Cl_minus["te"]/np.sqrt(Cl_minus["tt"]*Cl_minus["ee"])
          else:
              plus, minus = Cl_plus[s], Cl_minus[s]
          delta = (plus[lmin:lmax] - minus[lmin:lmax])/(2*epsilon*value)
          d[s] = delta if p != "logA" else delta*value

      deriv[i] = np.array([[d["tt"], d["te"]],
                           [d["te"], d["ee"]]])
#+END_SRC

#+RESULTS:
:results:
# Out[50]:
:end:

#+BEGIN_SRC ipython :session venv :results raw drawer
deriv.shape, inv_C.shape
#+END_SRC

#+RESULTS:
:results:
# Out[37]:
: ((5, 2, 2, 2950), (2, 2, 2950))
:end:

#+BEGIN_SRC ipython :session venv :results raw drawer
  nparam = len(params)
  fisher = np.empty((nparam,nparam))
  ls = np.arange(lmin, lmax)

  for p1 in range(nparam):
      for p2 in range(nparam):
          somme = 0.0
          for l in range(nell):
              m1 = np.dot(inv_C[:,:,l], deriv[p1,:,:,l])
              m2 = np.dot(inv_C[:,:,l], deriv[p2,:,:,l])
              somme += (2*ls[l]+1)/2*fsky*np.trace(np.dot(m1, m2))
          fisher[p1, p2] = somme
  cov = np.linalg.inv(fisher)
  print("eigenvalues = ", np.linalg.eigvals(cov))
  for count, p in enumerate(params):
      if p == "logA":
          value = np.log(1e10*setup_mod["simulation"]["cosmo. parameters"]["As"])
      else:
          value = setup_mod["simulation"]["cosmo. parameters"][p]
      print(p, value, np.sqrt(cov[count,count]))

  # print(cov)

#+END_SRC

#+RESULTS:
:results:
# Out[51]:
:end:

- TT with noise
  | cosmomc_theta | 0.0104085 | 3.2933741232560173e-06 |
  | logA          |     3.044 |  0.0042968435366678845 |
  | ns            |    0.9649 |    0.00419977568054334 |
  | ombh2         |   0.02237 | 0.00011485252438054256 |
  | omch2         |    0.1212 |  0.0014996312324999047 |

- TE with noise
  | cosmomc_theta | 0.0104085 | 1.8866899617573544e-06 |
  | logA          |     3.044 |   0.005727651857143012 |
  | ns            |    0.9649 |   0.004291586166845056 |
  | ombh2         |   0.02237 | 0.00010732709115913571 |
  | omch2         |    0.1212 |  0.0011281652102729464 |

- EE with noise
  | cosmomc_theta | 0.0104085 | 1.8381578861674736e-06 |
  | logA          |     3.044 |   0.003972553996340056 |
  | ns            |    0.9649 |   0.004709350724409364 |
  | ombh2         |   0.02237 | 0.00014877990544718571 |
  | omch2         |    0.1212 |  0.0010988558479663373 |

- TT_TE_EE with noise
  | cosmomc_theta | 0.0104085 | 1.1402521162479395e-06 |
  | logA          |     3.044 |  0.0022350121539707036 |
  | ns            |    0.9649 |  0.0023879663777635067 |
  | ombh2         |   0.02237 |  5.447897047605741e-05 |
  | omch2         |    0.1212 |  0.0006342926186782754 |
